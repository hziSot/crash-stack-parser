diff -Nur crash-6.1.6_orig/defs.h crash-6.1.6/defs.h
--- crash-6.1.6_orig/defs.h	2013-04-04 17:41:43.000000000 +0300
+++ crash-6.1.6/defs.h	2013-06-05 16:59:15.000000000 +0300
@@ -2852,6 +2852,100 @@
 #define _MAX_PHYSMEM_BITS_2_6_26  44
 #define _MAX_PHYSMEM_BITS_2_6_31  46
 
+
+#define DECLARE_REG_UNION_X(R) \
+    union { \
+        uint64_t r ## R ## x; \
+        struct { \
+            union { \
+                uint32_t e ## R ## x; \
+                struct { \
+                    union { \
+                        uint16_t R ## x; \
+                        struct { \
+                            uint8_t R ## l; \
+                            uint8_t R ## h; \
+                        }; \
+                    }; \
+                    unsigned char R ## x ## _res[2]; \
+                }; \
+            }; \
+            unsigned char e ## R ## _res[4]; \
+        }; \
+    }
+
+#define DECLARE_REG_UNION_IP(R) \
+    union { \
+        uint64_t r ## R; \
+        struct { \
+            union { \
+                uint32_t e ## R; \
+                struct { \
+                    union { \
+                        uint16_t R; \
+                        struct { \
+                            uint8_t R ## l; \
+                            uint8_t R ## l ## _res; \
+                        }; \
+                    }; \
+                    uint8_t R ## _res[2]; \
+                }; \
+            }; \
+            uint8_t e ## R ## _res[4]; \
+        }; \
+    }
+
+#define DECLARE_REG_UNION_R(R) \
+    union { \
+        uint64_t r ## R; \
+        struct { \
+            union { \
+                uint32_t r ## R ## d; \
+                struct { \
+                    union { \
+                        uint16_t r ## R ## w; \
+                        struct { \
+                            uint8_t r ## R ## b; \
+                            uint8_t r ## R ## b ## _res; \
+                        }; \
+                    }; \
+                    uint8_t r ## R ## w ## _res[2]; \
+                }; \
+            }; \
+            uint8_t r ## R ## d ## _res[4]; \
+        }; \
+    }
+
+#define DECLARE_REG_UNION_RIP \
+    union { \
+        uint64_t rip; \
+        struct { \
+            uint32_t eip; \
+            uint32_t rip_res; \
+        }; \
+    }
+
+#define OFF_X(R)    offsetof(__pr, r ## R ## x), offsetof(__pr, e ## R ## x), \
+                    offsetof(__pr, R ## x), offsetof(__pr, R ## h), offsetof(__pr, R ## l)
+
+#define OFF_IP(R)   offsetof(__pr, r ## R), offsetof(__pr, e ## R), \
+                    offsetof(__pr, R), 0, offsetof(__pr, R ## l)
+
+#define OFF_R(R)    offsetof(__pr, r ## R), offsetof(__pr, r ## R ## d), \
+                    offsetof(__pr, r ## R ## w), 0, offsetof(__pr, r ## R ## b)
+
+#define OFF_RIP     offsetof(__pr, rip), offsetof(__pr, eip), 0, 0, 0
+
+#define E_X(RR)     R ## RR ## X, E ## RR ## X, RR ## X, RR ## H, RR ## L
+#define E_IP(RR)    R ## RR, E ## RR, RR, FOO ## RR, RR ## L
+#define E_R(RR)     R ## RR, R ## RR ## D, R ## RR ## W, FOO ## RR, R ## RR ## L
+#define E_RIP       RIP, EIP, IP_FOO, IP_BAR, IP_BAZ
+
+#define S_X(RR)     "%r" RR "x", "%e" RR "x", "%" RR "x", "%" RR "h", "%" RR "l"
+#define S_IP(RR)    "%" "r" RR, "%" "e" RR, "%" RR, "foo" RR, "%" RR "l"
+#define S_R(RR)     "%r" RR, "%r" RR "d", "%r" RR "w", "foo" RR, "%r" RR "l"
+#define S_RIP       "%rip", "%eip", "ip_foo", "ip_bar", "ip_baz"
+
 #endif  /* X86_64 */
 
 #ifdef ALPHA
@@ -4598,6 +4692,7 @@
 #define BT_KDUMP_ELF_REGS   (0x80000000000ULL)
 #define BT_USER_SPACE      (0x100000000000ULL)
 #define BT_KERNEL_SPACE    (0x200000000000ULL)
+#define BT_TRACE_REGISTERS (0x400000000000ULL)
 #define BT_SYMBOL_OFFSET   (BT_SYMBOLIC_ARGS)
 
 #define BT_REF_HEXVAL         (0x1)
@@ -4860,6 +4955,92 @@
 
 #define _2MB_PAGE_MASK (~((MEGABYTES(2))-1))
 
+enum e_registers {
+//  0           1           2           3
+    E_X(A),     E_X(B),     E_X(C),     E_X(D),
+//  4           5           6           7
+    E_IP(DI),   E_IP(SI),   E_IP(BP),   E_IP(SP),
+//  8           9           10          11
+    E_R(8),     E_R(9),     E_R(10),    E_R(11),
+//  12          13          14          15
+    E_R(12),    E_R(13),    E_R(14),    E_R(15),
+//  16          17          Per-CPU
+    E_RIP,      RCOUNT,     GS_REG,     INVALID = 255,
+};
+
+enum e_instructions {
+    LEAVE, UD2, NOP, 
+    MOVZBL, MOVZWL, MOVSLQ, MOVSBL, MOVABS, MOV, CMOVE, CMOVNE,
+    PUSHF, PUSH, POPF, POP,
+    SUB, CALL, LEA, RET, XOR,
+    BTS, BTR, BT, CMP, TEST, INC, DEC,
+    JAE, JNE, JNZ, JBE, JNA, JNS, JMP,
+    JA, JB, JC, JE, JZ, JL, JS, OTHER_JUMP,
+    SHL, SHR, SAR, IMUL,
+    SBB, XADD, ADD, NOT, AND, OR,
+    ICOUNT
+};
+
+typedef struct parameter_registers {
+    DECLARE_REG_UNION_X(a);
+    DECLARE_REG_UNION_X(b);
+    DECLARE_REG_UNION_X(d);
+    DECLARE_REG_UNION_X(c);
+    DECLARE_REG_UNION_IP(si);
+    DECLARE_REG_UNION_IP(di);
+    DECLARE_REG_UNION_IP(bp);
+    DECLARE_REG_UNION_IP(sp);
+    DECLARE_REG_UNION_R(8);
+    DECLARE_REG_UNION_R(9);
+    DECLARE_REG_UNION_R(10);
+    DECLARE_REG_UNION_R(11);
+    DECLARE_REG_UNION_R(12);
+    DECLARE_REG_UNION_R(13);
+    DECLARE_REG_UNION_R(14);
+    DECLARE_REG_UNION_R(15);
+    DECLARE_REG_UNION_RIP;
+    uint64_t    params_mask;
+    uint8_t     params_regs[RCOUNT];
+    uint64_t    reliable;
+    uint64_t    was_touched;
+    char        zf; // Zero Flag
+    char        cf; // Carry Flag
+    char        sf; // Sign Flag
+    char        of; // Overflow Flag
+} __pr;
+
+struct code_line {
+    ulong   rip;
+    char    cmd[64];
+    char    first[64];
+    char    second[64];
+    char    third[64];
+    char    hit;
+    char    will_ret;
+};
+
+struct stack_frame_t {
+    char                        symbol[64];
+    uint64_t                    nearest;
+    uint64_t                    rip;
+    uint64_t                    rsp;
+    uint32_t                    len;
+    uint32_t                    allocated;
+    struct code_line            *code;
+    struct parameter_registers  regs;
+};
+
+struct stack_parser_context {
+    struct stack_frame_t *frames;
+    struct task_context *tc;
+    uint8_t frames_count;
+    uint8_t to_be_processed;
+    uint8_t should_get_stack_value;
+    uint64_t irq_count_offset;
+    uint64_t irq_count;
+    struct stack_parser_context *parent;
+};
+
 #endif
 
 #if defined(X86) || defined(X86_64)
diff -Nur crash-6.1.6_orig/kernel.c crash-6.1.6/kernel.c
--- crash-6.1.6_orig/kernel.c	2013-04-04 17:41:43.000000000 +0300
+++ crash-6.1.6/kernel.c	2013-06-05 16:52:16.000000000 +0300
@@ -72,6 +72,7 @@
 static void hypervisor_init(void);
 static void dump_log_legacy(void);
 static void dump_variable_length_record(void);
+void parse_stack(struct bt_info *bt);
 
 
 /*
@@ -1977,7 +1978,7 @@
 	if (kt->flags & USE_OLD_BT)
 		bt->flags |= BT_OLD_BACK_TRACE;
 
-        while ((c = getopt(argcnt, args, "D:fFI:S:aloreEgstTdxR:O")) != EOF) {
+        while ((c = getopt(argcnt, args, "D:fFI:S:aloreEgstTdxR:OH")) != EOF) {
                 switch (c)
 		{
 		case 'f':
@@ -2135,6 +2136,10 @@
 			bt->flags |= BT_TEXT_SYMBOLS;
 			break;
 
+                case 'H':
+                        bt->flags |= BT_TRACE_REGISTERS;
+                        break;
+
 		default:
 			argerrs++;
 			if (optopt == 'D') {
@@ -2559,6 +2564,11 @@
 	bt->instptr = eip;
 	bt->stkptr = esp;
 
+        if(bt->flags & BT_TRACE_REGISTERS) {
+            parse_stack(bt);
+            return;
+        }
+
 complete_trace:
 
 	if (BT_REFERENCE_CHECK(bt))
diff -Nur crash-6.1.6_orig/x86_64.c crash-6.1.6/x86_64.c
--- crash-6.1.6_orig/x86_64.c	2013-04-04 17:41:43.000000000 +0300
+++ crash-6.1.6/x86_64.c	2013-06-05 16:58:59.000000000 +0300
@@ -115,6 +115,121 @@
 static void GART_init(void);
 
 struct machine_specific x86_64_machine_specific = { 0 };
+/*
+#include <sys/types.h>
+#include <regex.h>
+*/
+#define REGEXP_RANGE(s, i) \
+        s + matchptr[i].rm_so, matchptr[i].rm_eo - matchptr[i].rm_so
+
+#define p_regs(R) ((char *)regs + offsets[R])
+#define p_prev_regs(R) ((char *)prev_regs + offsets[R])
+
+#define REGISTER_64BIT(r) ((r / 5) * 5)
+
+#ifdef __VERBOSE
+#define _VERBOSE(fp, ...) fprintf(fp, __VA_ARGS__)
+#else
+#define _VERBOSE(fp...)
+#endif
+
+/*
+ * Operation Suffixes
+ * b = byte (8 bit)
+ * s = short (16 bit integer) or single (32-bit floating point)
+ * w = word (16 bit)
+ * l = long (32 bit integer or 64-bit floating point)
+ * q = quad (64 bit)
+ * t = ten bytes (80-bit floating point)
+ */
+
+uint64_t registers_mask[] = {
+    0xffffffffffffffff,0x00000000ffffffff, 0x000000000000ffff,
+    0x00000000000000ff, 0x00000000000000ff,
+};
+uint64_t registers_msb[] = {
+    1ULL << 63, 1ULL << 31, 1ULL << 15, 1ULL << 7, 1ULL << 7,
+};
+const char *op_suffixes[]           = {"b", "s", "w", "l", "q"};
+const unsigned char op_width[]      = { 8,   8,   16,  32,  64,};
+
+const char *s_instructions[] = {
+    "leave", "ud2", "nop", 
+    "movzbl", "movzwl", "movslq", "movsbl", "movabs", "mov", "cmove", "cmovne",
+    "pushf", "push", "popf", "pop", 
+    "sub", "call", "lea", "ret", "xor", 
+    "bts", "btr", "bt", "cmp", "test", "inc", "dec", 
+    "jae", "jne", "jnz", "jbe", "jna", "jns", "jmp",
+    "ja", "jb", "jc", "je", "jz", "jl", "js", "j",
+    "shl", "shr", "sar", "imul",
+    "sbb", "xadd", "add", "not", "and", "or",
+};
+
+char *s_registers[] = {
+    S_X("a"),   S_X("b"),   S_X("c"),   S_X("d"),
+    S_IP("di"), S_IP("si"), S_IP("bp"), S_IP("sp"),
+    S_R("8"),   S_R("9"),   S_R("10"),  S_R("11"),
+    S_R("12"),  S_R("13"),  S_R("14"),  S_R("15"),
+    S_RIP,
+};
+
+int16_t offsets[] = {
+    OFF_X(a),   OFF_X(b),   OFF_X(c),   OFF_X(d),
+    OFF_IP(di), OFF_IP(si), OFF_IP(bp), OFF_IP(sp),
+    OFF_R(8),   OFF_R(9),   OFF_R(10),  OFF_R(11),
+    OFF_R(12),  OFF_R(13),  OFF_R(14),  OFF_R(15),
+    OFF_RIP,
+};
+
+uint8_t try_disassemble(const char *, uint64_t);
+void fill_mapped_register(struct stack_parser_context *, enum e_registers);
+void disassemble_frame(struct stack_frame_t *, unsigned char);
+void parse_stack(struct bt_info *bt);
+uint8_t parse_frame(
+        struct stack_parser_context *ctx, uint8_t, uint8_t,
+        uint8_t (*)(enum e_instructions, char*, char*)
+);
+uint8_t parse_argument(
+        struct stack_parser_context *, struct parameter_registers *,
+        char *, enum e_registers *, uint64_t *, uint8_t *
+);
+void update_flags(
+        uint64_t, enum e_registers, uint64_t, enum e_registers,
+        uint64_t, unsigned char, struct parameter_registers *
+);
+uint64_t str2dec(const char *, const char *);
+int8_t get_exception_no(const char *);
+uint64_t get_exception_displacement(int8_t);
+
+uint8_t get_register_width(enum e_registers);
+uint8_t is_stack_register(enum e_registers);
+uint8_t is_param_register(enum e_registers);
+uint8_t is_callee_save_register(enum e_registers);
+uint8_t is_compare_instruction(enum e_instructions);
+uint8_t is_jump_instruction(enum e_instructions);
+enum e_registers find_register(char *);
+enum e_instructions find_instr(const char *, int *);
+uint8_t save_args_callback(enum e_instructions, char *, char *);
+
+uint8_t is_mapped(struct parameter_registers *, enum e_registers);
+void set_mapping(struct parameter_registers *, enum e_registers, enum e_registers);
+void clean_mapping(struct parameter_registers *, enum e_registers);
+void set_reliable(struct parameter_registers *, enum e_registers);
+void clean_reliable(struct parameter_registers *, enum e_registers);
+uint8_t is_reliable(struct parameter_registers *, enum e_registers);
+
+uint64_t get_reg(struct parameter_registers *, enum e_registers);
+void set_reg(struct parameter_registers *, enum e_registers, uint64_t);
+void add_reg(struct parameter_registers *, enum e_registers, int64_t);
+
+uint64_t get_stack_value(struct stack_parser_context *, uint64_t, unsigned char);
+void split_command(const char *, char *, char *, char *, char *, char *);
+uint8_t get_memory_operand(char *, struct parameter_registers *, uint64_t *);
+void fill_frames(struct bt_info *, struct stack_parser_context *);
+uint8_t function_returns_value(const char *);
+void print_proto(struct stack_frame_t *, uint8_t, struct parameter_registers *);
+
+static uint8_t error_occured_while_reading;
 
 /*
  *  Do all necessary machine-specific setup here.  This is called several
@@ -2834,6 +2949,1931 @@
 	return FALSE;
 }
 
+uint8_t try_disassemble(const char *c, uint64_t cip) {
+        char b[BUFSIZE];
+
+        if(!c || !*c)
+            return 0;
+
+        open_tmpfile();
+
+        if(!strcmp(c, "system_call_fastpath"))
+            c = "system_call";
+        if(!strcmp(c, "ret_from_intr"))
+            c = "common_interrupt";
+        sprintf(b, "disassemble %s", c);
+        if (gdb_pass_through(b, fp, GNU_RETURN_ON_ERROR))
+            return 1;
+
+        if(cip && strcmp(c, "error_entry"))
+            sprintf(b, "disassemble %s, 0x%lx", c, cip);
+        else
+            sprintf(b, "x/150i %s", c);
+
+        if (!gdb_pass_through(b, fp, GNU_RETURN_ON_ERROR)) {
+            _VERBOSE(fp, "Error while disassembling '%s'\n", b);
+            close_tmpfile();
+            return 0;
+        }
+        return 1;
+}
+
+uint64_t str2dec(const char *s, const char *e) {
+    long long int r = 0, hex = 0, neg = 0;
+    neg = (*s == '-');
+    s += neg;
+    s += *s == '$' ? 1 : 0;
+    hex = (*s == '0' && *(s + 1) == 'x');
+    s += hex << 1;
+
+    while(e ? (s < e) : *s) {
+        r *= (hex ? 16 : 10);
+        if('0' <= (*s | 0x20) && (*s | 0x20) <= '9')
+            r += (*s | 0x20) - '0';
+        else if('a' <= (*s | 0x20) && (*s | 0x20) <= 'f')
+            r += (*s | 0x20) - 'a' + 10;
+        s++;
+    }
+
+    return (neg ? -1 : 1) * r;
+}
+/*
+unsigned char do_page_fault_callback(enum e_instructions instr_i, char *src, char *dst) {
+    if((instr_i == CALL) && (0xffffffff81503800 == str2dec(src, NULL)))
+        return 1;
+    return 0;
+}
+*/
+
+int8_t get_exception_no(const char *s) {
+    const char *traps_sym[] = {
+        "divide_error",                     // 0
+        "debug",                            // 1
+        "nmi",                              // 2
+        "int3",                             // 3
+        "overflow",                         // 4
+        "bounds",                           // 5
+        "invalid_op",                       // 6
+        "device_not_available",             // 7
+        "double_fault",                     // 8
+        "coprocessor_segment_overrun",      // 9
+        "invalid_TSS",                      // 10
+        "segment_not_present",              // 11
+        "stack_segment",                    // 12
+        "general_protection",               // 13
+        "page_fault",                       // 14
+        "spurious_interrupt_bug",           // 15
+        "coprocessor_error",                // 16
+        "alignment_check",                  // 17
+        "machine_check",                    // 18
+        "simd_coprocessor_error",           // 19
+        0
+    };
+    uint8_t i;
+
+    if(0 == (s && *s))
+        return -1;
+
+    for(i = 0; i < 19; i++)
+        if(!strcmp(traps_sym[i], s))
+            return i;
+
+    return -1;
+}
+
+uint64_t get_exception_displacement(int8_t e) {
+    if(0 <= e && e <= 7)
+        return 5 * 0x8;
+    switch(e) {
+        case 9:
+        case 15:
+        case 16:
+        case 18:
+        case 19:
+            return 5 * 0x8;
+        default:
+            return 6 * 0x8;
+    }
+}
+
+uint8_t is_param_register(enum e_registers reg) {
+        switch(reg / 5 * 5) {
+            case RDI:
+            case RSI:
+            case RDX:
+            case RCX:
+            case R8:
+            case R9:
+            case R10:
+                return 1;
+            default:
+                return 0;
+        }
+}
+
+uint8_t is_callee_save_register(enum e_registers reg) {
+        switch(reg / 5 * 5) {
+            case RBX:
+            case RBP:
+            case R12:
+            case R13:
+            case R14:
+            case R15:
+                return 1;
+            default:
+                return 0;
+        }
+}
+
+uint8_t is_compare_instruction(enum e_instructions i) {
+    switch(i) {
+        case BT:
+        case BTS:
+        case BTR:
+        case CMP:
+        case TEST:
+            return 1;
+        default:
+            return 0;
+    }
+}
+
+uint8_t is_jump_instruction(enum e_instructions i) {
+    switch(i) {
+        case JAE:
+        case JNE:
+        case JNZ:
+        case JBE:
+        case JNA:
+        case JNS:
+        case JMP:
+        case JA:
+        case JB:
+        case JC:
+        case JE:
+        case JZ:
+        case JL:
+        case OTHER_JUMP:
+            return 1;
+        default:
+            return 0;
+    }
+}
+
+enum e_registers find_register(char *r) {
+        int i;
+        if(r && *r)
+            for (i = 0; i < RCOUNT; i++)
+                    if(!strcmp(r, s_registers[i]))
+                            return i;
+
+        return INVALID;
+}
+
+enum e_instructions find_instr(const char *s, int *width) {
+        int i, j;
+        if(s && *s)
+            for(i = 0; i < ICOUNT; i++)
+                if(!strncmp(s, s_instructions[i], strlen(s_instructions[i])))
+                    break;
+        if(i == ICOUNT)
+            return -1;
+
+        if(strlen(s_instructions[i]) == strlen(s)) {
+            if(width) *width = 64;
+            return i;
+        }
+
+        for(j = 0; j <= 4; j++)
+            if(0 == strcmp(s + strlen(s_instructions[i]), op_suffixes[j])) {
+                if(width) *width = op_width[j];
+                return i;
+            }
+
+        return -1;
+}
+
+uint8_t save_args_callback(enum e_instructions instr_i, char *src, char *dst) {
+    if(instr_i == PUSH && RBP == find_register(src))
+        return 1;
+    return 0;
+}
+
+uint8_t is_mapped(struct parameter_registers *regs, enum e_registers r) {
+    if(r == INVALID)
+        return 0;
+    return !!(regs->params_mask & (1 << (r / 5)));
+}
+
+void set_mapping(struct parameter_registers *regs, enum e_registers cs, enum e_registers p) {
+    if(cs == INVALID || p == INVALID)
+        return;
+    if(is_mapped(regs, cs))
+        clean_mapping(regs, cs);
+    if(is_mapped(regs, p))
+        clean_mapping(regs, p);
+    // If we have instruction
+    //    mov %rbx,%rdi
+    // let's make our life easier with mutual mapping, that is
+    // - rbx => rdi
+    // - rdi => rbx
+
+    regs->params_mask |= (1 << (cs / 5)) | (1 << (p / 5));
+    regs->params_regs[cs] = p;
+    regs->params_regs[p] = cs;
+    _VERBOSE(fp, "\t\tSET MAPPING: Value of %s <=> %s", s_registers[cs], s_registers[p]);
+}
+
+void clean_mapping(struct parameter_registers *regs, enum e_registers r) {
+//    int i;
+    enum e_registers i, rm;
+    if(INVALID == r || !is_mapped(regs, r))
+        return;
+
+    for(i = r / 5 * 5; i < (r / 5 + 1) * 5; i++) {
+        if(is_mapped(regs, regs->params_regs[i]))
+//        if(INVALID != regs->params_regs[i])
+            rm = regs->params_regs[i];  // Mapped register
+        regs->params_regs[i] = INVALID;
+    }
+
+    if(INVALID == rm)
+        _VERBOSE(fp, "\t\tsomething wrong while cleaning mapping for register '%s'", s_registers[r]);
+
+    regs->params_mask &= ~( (1 << (r / 5)) | (1 << (rm / 5)));
+
+    for(i = rm / 5 * 5; i < (rm / 5 + 1) * 5; i++)
+        regs->params_regs[i] = INVALID;
+
+    _VERBOSE(fp, "\t\tREMOVE MAPPING for register: %s (%s) <=> %s (%s)", s_registers[r / 5 * 5], s_registers[r], s_registers[rm / 5 * 5], s_registers[rm]);
+}
+
+void set_reliable(struct parameter_registers *regs, enum e_registers r) {
+    if(INVALID == r) return;
+    regs->reliable |= (1 << (r / 5));
+}
+
+void clean_reliable(struct parameter_registers *regs, enum e_registers r) {
+    if(INVALID == r) return;
+    regs->reliable &= ~(1 << (r / 5));
+}
+
+uint8_t is_reliable(struct parameter_registers *regs, enum e_registers r) {
+    if(INVALID == r) return 0;
+    return ((regs->reliable & (1 << (r / 5))) != 0);
+}
+
+uint64_t get_reg(struct parameter_registers *regs, enum e_registers r) {
+    if(INVALID == r) return 0;
+    return (*((uint64_t*)p_regs(r)) & registers_mask[r % 5]);
+}
+
+uint8_t get_register_width(enum e_registers r) {
+    if(INVALID == r)
+        return 0;
+    switch(r % 5) {
+        case 0: return 64;
+        case 1: return 32;
+        case 2: return 16;
+        case 3: return 8;
+        case 4: return 8;
+        default: return 0;
+    }
+}
+
+void set_reg(struct parameter_registers *regs, enum e_registers r, uint64_t value) {
+    if(r == INVALID)
+        return;
+
+    value = value & registers_mask[r % 5];
+
+    switch(r % 5) {
+        case 0:
+            *((uint64_t*)p_regs(r)) = value;
+        case 1:
+            *((uint32_t*)p_regs(r)) = value;
+        case 2:
+            *((uint16_t*)p_regs(r)) = value;
+        case 3:
+            *((uint8_t*)p_regs(r)) = value;
+        case 4:
+            *((uint8_t*)p_regs(r)) = value;
+    }
+}
+
+void add_reg(struct parameter_registers *regs, enum e_registers r, int64_t delta) {
+    set_reg(regs, r, get_reg(regs, r) + delta);
+}
+
+void fill_mapped_register(
+        struct stack_parser_context *ctx,
+        enum e_registers r
+) {
+    struct parameter_registers 
+        *regs = &(ctx->frames + ctx->to_be_processed)->regs,
+        *prev_regs;
+
+    enum e_registers untouchable, mr /*Mapped register */;
+    uint8_t mapping = 1;
+    uint32_t i, f;
+
+    if(0 == ctx->to_be_processed || INVALID == r)
+        return;
+
+    for(f = ctx->to_be_processed; f < ctx->frames_count - 2;) {
+        regs        = &(ctx->frames + f)->regs;
+        prev_regs   = &(ctx->frames + f + 1)->regs;
+
+        if(NULL == prev_regs || NULL == regs)
+            return;
+        if(mapping) {
+            // Start with mapped registers
+            if(0 == is_mapped(prev_regs, r)) {
+                // NOTE: that we're using `mr` from the
+                // current branch in order to determine
+                // necessary register for the next branch
+                if(1 == is_param_register(r) && 0 == (regs->was_touched & (1 << (r / 5))))
+                    untouchable = r;
+                else if(1 == is_param_register(mr) && 0 == (regs->was_touched & (1 << (mr / 5))))
+                    untouchable = mr;
+                else
+                    return;
+
+                mapping = 0;
+                continue;
+            }
+            for(i = r / 5 * 5; i < (r / 5 + 1) * 5; i++) {
+                if(INVALID == (mr = prev_regs->params_regs[i]))
+                    continue;
+                set_reg(prev_regs, prev_regs->params_regs[i], get_reg(regs, r));
+                set_reg(prev_regs, i, get_reg(regs, r));
+                set_reg(regs, prev_regs->params_regs[i], get_reg(regs, r));
+                _VERBOSE(fp, "\t\tMAPPING for frame '%s': Values: %s is 0x%lx and %s is 0x%lx now", 
+                        (ctx->frames + f + 1)->symbol, 
+                        s_registers[prev_regs->params_regs[i]], 
+                        get_reg(prev_regs, prev_regs->params_regs[i]),
+                        s_registers[i], 
+                        get_reg(prev_regs, i)
+                );
+                set_reliable(prev_regs, prev_regs->params_regs[i]);
+                set_reliable(prev_regs, i);
+                set_reliable(regs, prev_regs->params_regs[i]);
+                clean_mapping(prev_regs, i);
+                if(
+                        (-1 != get_exception_no((ctx->frames + f + 1)->symbol)) ||
+                        (0 == strcmp((ctx->frames + f + 1)->symbol, "apic_timer_interrupt")) ||
+                        (0 == strcmp((ctx->frames + f + 1)->symbol, "common_interrupt"))
+                )
+                    return;
+
+                break;
+            }
+        } else {
+            // Afterwards try to fill registers which
+            // were not touched while frame executing
+            if(0 == (regs->was_touched & (1 << (untouchable / 5))))
+                set_reg(prev_regs, untouchable, get_reg(regs, untouchable));
+            else
+                break;
+            if(is_reliable(regs, untouchable)) {
+                set_reliable(prev_regs, untouchable);
+            } else  {
+                clean_reliable(prev_regs, untouchable);
+            }
+            _VERBOSE(fp, "\t\tPOSTMAPPING for frame '%s': Values: %s is 0x%lx now",
+                    (ctx->frames + f + 1)->symbol,
+                    s_registers[untouchable],
+                    get_reg(prev_regs, untouchable)
+            );
+        }
+        f++;
+    }
+
+    return;
+}
+
+uint64_t get_stack_value(struct stack_parser_context *ctx, uint64_t addr, unsigned char width) {
+    uint64_t t = 0;
+    error_occured_while_reading = 0;
+    if(!ctx->should_get_stack_value)
+        return 0;
+
+    if (!IS_KVADDR(addr))
+        return 0;
+
+    if(!width)
+        width = 64;
+
+    if(FALSE == readmem(addr, KVADDR, &t, width / 8, "long integer", RETURN_ON_ERROR | QUIET))
+        error_occured_while_reading = 1;
+
+    return t;
+}
+
+void split_command(const char *b, char *command, char *first, char *second, char *third, char *addr) {
+        const char re_s[] = "^[ \t]*(0x[a-f0-9]+)"                          // Address 
+                            ".*:[ \t]+(lock[ \t]+)?([a-z0-9]+)([ \t]+)?"    // Some rubbish + command
+                            "([^ ]+)?( +[<#].*)?\n";                        // Single/both parameters (in single match)
+                                                                            // and <func name> in `call`
+
+        unsigned char p = 0;
+        char *m, *mm;   // Main marker & middle marker
+        regex_t re;
+        regmatch_t matchptr[7];
+        if(regcomp(&re, re_s, REG_EXTENDED) || regexec(&re, b, 7, matchptr, 0))
+                return;
+        if(addr)
+            memcpy(addr, REGEXP_RANGE(b, 1));
+
+        memcpy(command, REGEXP_RANGE(b, 3));
+        *second = 0;
+        *third = 0;
+        if(-1 == matchptr[5].rm_so) {
+            *first = 0;
+            return;
+        }
+        memcpy(first, REGEXP_RANGE(b, 5));
+        m = first;
+        while(1) {
+            if (*m == '\0')
+                break;
+            else if(*m == '(')
+                p = 1;
+            else if(*m == ')')
+                p = 0;
+            else if(0 == p && 0 == *second && *m == ',') {
+                strcpy(second, m + 1);
+                mm = m + 1;
+                *m = '\0';
+            } else if(!p && *m == ',') {
+                *(second + (m - mm)) = '\0';
+                strcpy(third, m + 1);
+                *m = '\0';
+            }
+            m++;
+        }
+}
+
+uint8_t get_memory_operand(char *arg, struct parameter_registers *regs, uint64_t *p_val) {
+    char displ[16] = {0}, base[8] = {0}, offs[8] = {0}, mul[16] = "1";
+    int base_i, offs_i;
+
+    char *pb1, *pc1, *pc2, *pb2;
+
+    *p_val = 0;
+
+    if(NULL != (pb1 = strstr(arg, "("))) {
+        pb2 = strstr(pb1, ")");
+        if(NULL != (pc1 = strstr(pb1 + 1, ",")))
+            pc2 = strstr(pc1 + 1, ",");
+        // We've got:
+        // displacement(base register, offset register, scalar multiplier)
+        //             |             |                |                  |
+        //             pb1          pc1              pc2                pb2
+        strncpy(displ, arg, pb1 - arg);
+        if(pc1) {
+            strncpy(base, pb1 + 1, pc1 - pb1 - 1);
+            if(pc2)
+                strncpy(offs, pc1 + 1, pc2 - pc1 - 1);
+            else
+                pc2 = pc1;
+            strncpy(mul, pc2 + 1, pb2 - pc2 - 1);
+        } else {
+            strncpy(base, pb1 + 1, pb2 - pb1 - 1);
+        }
+        if(*offs) {
+            offs_i = find_register(offs);
+            if(INVALID != offs_i) {
+                if(is_reliable(regs, offs_i))
+                    *p_val = get_reg(regs, offs_i) * str2dec(mul, NULL);
+                else
+                    return 0; // Unreliable register
+            }
+        }
+        if(*base) {
+            base_i = find_register(base);
+            if(INVALID != base_i) {
+                if(is_reliable(regs, base_i))
+                    *p_val += get_reg(regs, base_i);
+                else
+                    return 0; // Unreliable register
+            }
+        }
+
+        *p_val += str2dec(displ, NULL);
+    } else {
+        if('%' == *arg) {
+            // Register here
+        } else {
+            // Immediate here
+            *p_val = str2dec(arg, NULL);
+        }
+    }
+    return 1;
+}
+
+/*
+static unsigned int find_frame_pointer(char *fname, ulong rip, FILE *ofp) {
+        char b[BUFSIZE];
+        char next_call[20];
+        unsigned int offset = 0;
+        if(!try_disassemble(fname, rip, ofp)) {
+                return 0;
+        }
+        rewind(pc->tmpfile);
+        char addr[19] = {0};
+        while(fgets(b, BUFSIZE, pc->tmpfile)) {
+                char command[64] = {0}, src[64] = {0}, dst[64] = {0};
+                if(!*command)
+                    continue;
+                split_command(b, command, src, dst, addr);
+                if(CALL == (find_instr(command, NULL))) {
+                        strncpy(next_call, src, 20);
+                        continue;
+                }
+                if(str2dec(addr, NULL) == rip)
+                        break;
+        }
+        close_tmpfile();
+
+        // Found call address
+        if(str2dec(addr, NULL) == rip && *addr == '0' && *(addr + 1) == 'x') {
+                if(!try_disassemble(next_call, 0, ofp))
+                        return 0;
+        } else
+                return 0;
+
+        rewind(pc->tmpfile);
+
+        while(fgets(b, BUFSIZE, pc->tmpfile)) {
+                char command[64] = {0}, src[64] = {0}, dst[64] = {0};
+                split_command(b, command, src, dst, addr);
+                if(PUSH == find_instr(command, NULL)) {
+                        if(RBP == find_register(src)) {
+                                close_tmpfile();
+                                return offset;
+                        }
+                        else
+                                offset += 8;
+                }
+        }
+        close_tmpfile();
+
+        return 0;
+}
+*/
+
+/*
+uint64_t get_call_address_before_rip(uint64_t rip) {
+    char b[BUFSIZE], b2[BUFSIZE];
+    if(!try_disassemble(closest_symbol(rip), rip, fp))
+        return 0;
+    rewind(pc->tmpfile);
+    while(fgets(b, BUFSIZE, pc->tmpfile)) {
+        char command[64] = {0}, src[64] = {0}, dst[64] = {0}, addr[19] = {0};
+        split_command(b, command, src, dst, addr);
+        if(!*command)
+            continue;
+        if(*b2 && *addr && (str2dec(addr, NULL) == rip)) {
+            split_command(b2, command, src, dst, addr);
+            if(!*src)
+                return 0;
+            close_tmpfile();
+            return str2dec(src, NULL);
+        }
+        strncpy(b2, b, BUFSIZE);
+    }
+    close_tmpfile();
+    return 0;
+}
+*/
+
+void fill_frames(struct bt_info *bt, struct stack_parser_context *ctx) {
+         uint64_t frame_stack_rip, frame_stack_rsp = bt->stkptr - 8;
+         char *frame_stack_sym;
+         uint64_t temp_rsp;
+         uint64_t frame_offset = 0;
+         char *prev_sym;
+         uint64_t prev_rip;
+         char buf[BUFSIZE], *t;
+         struct syment *sp;
+         uint64_t init_tss, ist;
+         struct stack_frame_t *p_cframe = ctx->frames;
+         uint64_t pf_temp_rsp;
+         int8_t except_no;
+         uint8_t exception_encountered = 0;
+ 
+         sp = per_cpu_symbol_search("irq_count");
+ 
+         ctx->parent = NULL;
+         ctx->frames_count = 0;
+         ctx->to_be_processed = 0;
+         ctx->tc = task_to_context(bt->task);
+ 
+         ctx->irq_count_offset = kt->__per_cpu_offset[ctx->tc->processor] + sp->value;
+         ctx->irq_count = -1;
+ 
+         while(frame_stack_rsp && ctx->frames_count <= 63) {
+             frame_offset = 0;
+             frame_stack_sym = NULL;
+             t = NULL;
+ 
+             readmem(
+                     frame_stack_rsp + 8, KVADDR, &frame_stack_rip,
+                     8, "long integer", RETURN_ON_ERROR
+             );
+             if(frame_stack_rip)
+                 frame_stack_sym = closest_symbol(frame_stack_rip - 5);
+             else {
+                 readmem(
+                         frame_stack_rsp,
+                         KVADDR, &frame_stack_rsp, 8, "long integer", RETURN_ON_ERROR
+                        );
+                 continue;
+             }
+ 
+             p_cframe->len               = 0;
+             p_cframe->allocated         = 0;
+             p_cframe->code              = NULL;
+             p_cframe->regs.reliable     = 0ULL;
+             p_cframe->regs.params_mask  = 0ULL;
+             memset(p_cframe->regs.params_regs, 0xff, RCOUNT);
+ 
+             if(frame_stack_sym && !strcmp(frame_stack_sym, "system_call_fastpath")) {
+                 // XXX: Remove hardcoded value?
+                 readmem(0xcbc8 + kt->__per_cpu_offset[ctx->tc->processor], KVADDR, 
+                         &temp_rsp, 8, "long integer", RETURN_ON_ERROR);
+                 // XXX: Remove hardcoded value 
+                 strcpy(p_cframe->symbol, "system_call");
+                 p_cframe->rip       = frame_stack_rip;
+                 p_cframe->rsp       = temp_rsp + 8;
+                 _VERBOSE(fp, "RSP: 0x%lx; RIP: 0x%lx; symbol: %s\n", p_cframe->rsp, p_cframe->rip, p_cframe->symbol);
+                 
+                 disassemble_frame(p_cframe, 0);
+                 p_cframe++;
+                 ctx->frames_count++;
+                 ctx->to_be_processed++;
+ 
+                 break;
+             }
+ 
+             if(frame_stack_sym && !strcmp(frame_stack_sym, "machine_kexec"))
+                 frame_offset = 8; //find_frame_pointer(frame_stack_sym, frame_stack_rip, ofp);
+ 
+             readmem(
+                     frame_stack_rsp - frame_offset,
+                     KVADDR, &temp_rsp, 8, "long integer", RETURN_ON_ERROR
+             );
+ 
+ 
+             if(frame_stack_rip) {
+                 strcpy(p_cframe->symbol, frame_stack_sym);
+                 p_cframe->rip    = frame_stack_rip;
+                 disassemble_frame(p_cframe, 0);
+             }
+ 
+             except_no = get_exception_no(frame_stack_sym);
+             if(-1 == except_no)
+                 p_cframe->rsp = temp_rsp + 8;
+ 
+             if(exception_encountered) {
+                 exception_encountered = 0;
+                 disassemble_frame(p_cframe, 0);
+                 pf_temp_rsp = p_cframe->rsp;
+                 p_cframe->rsp = 0;
+                 set_reliable(&p_cframe->regs, RSP);
+                 parse_frame(ctx,  1, 0, 0);
+                 (p_cframe - 1)->rsp = pf_temp_rsp - (0 - p_cframe->regs.rsp); // - 0x8;
+                 p_cframe->rsp = pf_temp_rsp;
+                 _VERBOSE(fp, "RSP: 0x%lx; RIP: 0x%lx; symbol: %s\n", (p_cframe - 1)->rsp, (p_cframe - 1)->rip, (p_cframe - 1)->symbol);
+                 (p_cframe - 1)->regs.reliable       = 0ULL;
+                 (p_cframe - 1)->regs.params_mask    = 0ULL;
+                 disassemble_frame(p_cframe - 1, 0);
+                 memset((p_cframe - 1)->regs.params_regs, 0xff, RCOUNT);
+             }
+ 
+ 
+             // Here we'll fix read RSP in case of:
+             // 1. Current frame is exception entry point
+             // 2. TSS contain IST != 0
+             if((-1 != except_no) ||
+                     (frame_stack_sym && 
+                         (0 == strcmp(frame_stack_sym, "apic_timer_interrupt") ||
+                         0 == strcmp(frame_stack_sym, "common_interrupt"))
+                     )
+             ) {
+                     // Here we will read corresponding IST
+                     // from per_cpu__init_tss.ist[index].
+                     // Index will be read from idt_table[interrupt_#].ist
+                     if(-1 != except_no) {
+                             // RSP doesn't belong to this frame but to crashed function
+                             // So, going to find crashed function name
+                             // Read IST value from IDT
+                             sprintf(buf, "p/x idt_table[%d].ist", except_no);
+                             open_tmpfile2();
+                             if (!gdb_pass_through(buf, pc->tmpfile2, GNU_RETURN_ON_ERROR)) {
+                                 close_tmpfile2();
+                                 error(INFO, "gdb request failed: %s\n", buf);
+                                 return;
+                             }
+                             rewind(pc->tmpfile2);
+                             fgets(buf, BUFSIZE, pc->tmpfile2);
+                             buf[strlen(buf) - 1] = 0; // Chop trailing '\n'
+                             close_tmpfile2();
+                             t = strstr(buf, "= ");
+                             if(!t)
+                                 return;
+                             ist = str2dec(t + 2, NULL);
+                     } else
+                             ist = 0;
+ 
+                     if(ist) {
+                             // If IST specify, read it
+                             sp = per_cpu_symbol_search("init_tss");
+                             init_tss = sp->value + kt->__per_cpu_offset[ctx->tc->processor];
+                             
+                             sprintf(buf, "p/x (( struct tss_struct *) 0x%lx).x86_tss.ist[%lu]", init_tss, ist - 1);
+ 
+                             open_tmpfile2();
+                             if (!gdb_pass_through(buf, pc->tmpfile2, GNU_RETURN_ON_ERROR)) {
+                                 close_tmpfile2();
+                                 error(INFO, "gdb request failed: %s\n", buf);
+                                 return;
+                             }
+                             rewind(pc->tmpfile2);
+                             fgets(buf, BUFSIZE, pc->tmpfile2);
+                             buf[strlen(buf) - 1] = 0; // Chop trailing '\n'
+                             close_tmpfile2();
+                             t = strstr(buf, "= ");
+                             if(!t)
+                                 return;
+                             if(str2dec(t + 2, NULL))
+                                 p_cframe->rsp = str2dec(t + 2, NULL);
+                     } else {
+                             // Otherwise calculate frame start
+                             p_cframe->rsp = 0;
+                             set_reliable(&p_cframe->regs, RSP);
+ 
+                             p_cframe->len       = 0;
+                             p_cframe->allocated = 0;
+                             p_cframe->code      = NULL;
+                             disassemble_frame(p_cframe, 0);
+                             if(0 == strcmp(frame_stack_sym, "page_fault"))
+                                     p_cframe->rsp = ((p_cframe - 1)->rsp + 0xa8 + 0x8);
+                             else {
+                                     parse_frame(ctx, 1, 0, save_args_callback);
+                                     p_cframe->regs.reliable    = 0ULL;
+                                     p_cframe->regs.params_mask = 0ULL;
+                                     memset(p_cframe->regs.params_regs, 0xff, RCOUNT);
+ 
+                                     p_cframe->rsp = temp_rsp + (0 - p_cframe->regs.rsp) - 0x8;
+                             }
+                             p_cframe->rsp &= ~((uint64_t )0x8);
+                     }
+ 
+ 
+                     /* Read RIP off unconditionally saved registers */
+                     readmem(p_cframe->rsp - 0x28, KVADDR,
+                             &prev_rip, 8, "long integer", RETURN_ON_ERROR);
+ 
+                     /*
+                      * If saved RIP is zero, probably is was caused by `call 0`,
+                      * so, let's read return RIP
+                      */
+                     if(!prev_rip)
+                         readmem(p_cframe->rsp, KVADDR,
+                                 &prev_rip, 8, "long integer", RETURN_ON_ERROR);
+ 
+                     _VERBOSE(fp, "RSP: 0x%lx; RIP: 0x%lx; symbol: %s\n", p_cframe->rsp, p_cframe->rip, p_cframe->symbol);
+                     if((prev_sym = closest_symbol(prev_rip))) {
+                             strcpy((p_cframe + 1)->symbol, prev_sym);
+                             (p_cframe + 1)->rip = prev_rip;
+                             exception_encountered = 1;
+                             p_cframe += 2;
+                             ctx->frames_count += 2;
+                             ctx->to_be_processed += 2;
+                     }
+             } else if(frame_stack_rip) {
+                 _VERBOSE(fp, "RSP: 0x%lx; RIP: 0x%lx; symbol: %s\n", p_cframe->rsp, p_cframe->rip, p_cframe->symbol);
+                 p_cframe++;
+                 ctx->frames_count++;
+                 ctx->to_be_processed++;
+             }
+ 
+             if(frame_stack_sym && 0 == strcmp(frame_stack_sym, "cpu_idle"))
+                 break;
+             frame_stack_rsp = temp_rsp;
+         }
+}
+
+uint8_t function_returns_value(const char *name) {
+        char b[BUFSIZE];
+        if(!name)
+            return 0;
+        sprintf(b, "ptype %s", name);
+        open_tmpfile2();
+
+        if (!gdb_pass_through(b, pc->tmpfile2, GNU_RETURN_ON_ERROR)) {
+                close_tmpfile2();
+                error(INFO, "gdb request failed: ptype %s\n", name);
+        }
+
+        rewind(pc->tmpfile2);
+        while (fgets(b, BUFSIZE, pc->tmpfile2)) {
+                if (strstr(b, "type = "))
+			break;
+        }
+        close_tmpfile2();
+        if (strstr(b, "type = void ("))
+                return 0;
+        else
+                return 1;
+}
+
+void print_proto(struct stack_frame_t *f, uint8_t n, struct parameter_registers *regs) {
+        const char *sym = f->symbol;
+        char b[BUFSIZE], type[BUFSIZE] = "p sizeof(", type_buf[BUFSIZE];
+        char *s, *e;
+        enum e_registers params[] = {RDI, RSI, RDX, RCX, R8, R9};
+        uint64_t param_mask;
+        uint8_t r_i = 0;
+
+        if(!sym || !*sym)
+            return;
+
+        sprintf(b, "ptype %s", sym);
+        open_tmpfile2();
+
+        if (!gdb_pass_through(b, pc->tmpfile2, GNU_RETURN_ON_ERROR)) {
+                close_tmpfile2();
+                error(INFO, "gdb request failed: ptype %s\n", sym);
+                return;
+        }
+
+        rewind(pc->tmpfile2);
+        while (fgets(b, BUFSIZE, pc->tmpfile2)) {
+                if (NULL != (s = strstr(b, "type = ")))
+			break;
+        }
+        
+        close_tmpfile2();
+
+        if(NULL == (s = strstr(b, "(")))
+            return;
+        s++;
+        e = s;
+        
+        fprintf(fp, "#%4d: [RSP: 0x%lx, RIP: 0x%lx] %s (", n, f->rsp, f->rip, sym);
+                
+
+        for(; *e; e++) {
+            if(0 == strncmp(s, "void)", 5))
+                break;
+            if((*e == ')' || *e == ',') && s < e) {
+                strncpy(type + 9, s, e - s);
+                type[9 + e - s] = ')';
+                type[10 + e - s] = 0;
+                open_tmpfile2();
+                if (!gdb_pass_through(type, pc->tmpfile2, GNU_RETURN_ON_ERROR)) {
+                    close_tmpfile2();
+                    error(INFO, "gdb request failed: ptype %s\n", sym);
+                    return;
+                }
+                rewind(pc->tmpfile2);
+                fgets(type_buf, BUFSIZE, pc->tmpfile2);
+                type_buf[strlen(type_buf) - 1] = 0; // Chop trailing '\n'
+                close_tmpfile2();
+                
+
+                for(; s < e; s++)
+                    fprintf(fp, "%c", *s);
+
+                if(0 == (s = strstr(type_buf, " = ")))
+                    return;
+                param_mask = 0;
+                switch(str2dec(s + 3, NULL)) {
+                    case 8:
+                        param_mask |= 0xffffffffffffffff;
+                    case 4:
+                        param_mask |= 0x00000000ffffffff;
+                    case 2:
+                        param_mask |= 0x000000000000ffff;
+                    case 1:
+                        param_mask |= 0x00000000000000ff;
+                }
+
+                if(is_reliable(regs, params[r_i])) {
+                    fprintf(fp, " arg = 0x%lx", param_mask & get_reg(regs, params[r_i]));
+                } else {
+                    fprintf(fp, " arg = unknown");
+                }
+
+                r_i++;
+                if(*e == ')') break;
+                fprintf(fp, ", ");
+                s = e;
+                while(*s == ',' || *s == ' ') s++;
+                e = s;
+            }
+        }
+        fprintf(fp, ")\n");
+}
+
+uint8_t is_stack_register(enum e_registers r) {
+    switch(r) {
+        case RBP:
+        case RSP:
+        case EBP:
+        case ESP:
+        case BP:
+        case SP:
+        case BPL:
+        case SPL:
+            return 1;
+        default:
+            return 0;
+    }
+}
+
+void disassemble_frame(struct stack_frame_t *frame, unsigned char will_ret) {
+#define MIN_CODE_BUFFER     128
+    char b[BUFSIZE];
+    int instr_i;
+    uint64_t jump_to;
+    int i, j, k;
+    int last_checkpoint = 0;
+    struct load_module *lm;
+    uint8_t external_marked, internal_marked;
+
+
+
+    if(module_symbol(frame->rip, NULL, &lm, NULL, 0)) {
+        _VERBOSE(fp, "Module: %s\n", lm->mod_name);
+        load_module_symbols_helper(lm->mod_name);
+    }
+
+    if(!try_disassemble(frame->symbol, frame->rip)) {
+        _VERBOSE(fp, "Oops: %s .. 0x%lx\n", frame->symbol, frame->rip);
+        return;
+    }
+
+    rewind(pc->tmpfile);
+    while(fgets(b, BUFSIZE, pc->tmpfile)) {
+        char command[64] = {0}, addr[20] = {0};
+        char    first[64] = {0}, second[64] = {0}, third[64] = {0};
+
+        split_command(b, command, first, second, third, addr);
+        if(0 == *command)
+            continue;
+
+        if(frame->len == frame->allocated) {
+            frame->code = realloc(frame->code, sizeof(struct code_line) * (MIN_CODE_BUFFER + frame->allocated));
+            if(frame->code)
+                frame->allocated += MIN_CODE_BUFFER;
+            else
+                error(FATAL, "Can't allocate memory for disassembled code");
+        }
+
+        frame->code[frame->len].rip = str2dec(addr, NULL);
+        memcpy(frame->code[frame->len].cmd, command, 64);
+        memcpy(frame->code[frame->len].first, first, 64);
+        memcpy(frame->code[frame->len].second, second, 64);
+        memcpy(frame->code[frame->len].third, third, 64);
+        frame->code[frame->len].hit = 0;
+        frame->code[frame->len].will_ret = 0;
+        frame->len++;
+    }
+#undef MIN_CODE_BUFFER
+
+    // Don't fill .will_ret field for function
+    // error_entry, irq_to_desc, save_args
+    // We will return from them
+    if(will_ret) {
+        close_tmpfile();
+        return;
+    }
+
+    // The 0-th pass
+    for(j = 0; j < frame->len; j++) {
+        if(0 == *frame->code[j].cmd)
+            continue;
+        instr_i = find_instr(frame->code[j].cmd, NULL);
+
+        if(
+                is_jump_instruction(instr_i) ||
+                // Instruction after CALL is the return address
+                (CALL == instr_i && (j + 1) < frame->len && frame->code[j + 1].rip == frame->rip)
+        ) {
+            jump_to = str2dec(frame->code[j].first, NULL);  // .first parameter == jump address
+            if(is_jump_instruction(instr_i)) {
+                if(frame->nearest) {
+                    if((j + 1 < frame->len) && (frame->code[j].rip < frame->rip) && (frame->code[j].rip > frame->nearest))
+                        frame->nearest = frame->code[j + 1].rip;
+                } else if((j + 1 < frame->len) && frame->code[j].rip < frame->rip) {
+                    frame->nearest = frame->code[j + 1].rip;
+                }
+            }
+            last_checkpoint = j;
+        }
+
+        // This hack is necessary for the following case:
+        //
+        // callq  0xffffffff81503180 <kprobe_fault_handler>
+        // test   %eax,%eax
+        // je     0xffffffff8104457e <__do_page_fault+494>
+        // mov    -0x28(%rbp),%rbx
+        // mov    -0x20(%rbp),%r12
+        // mov    -0x18(%rbp),%r13
+        // mov    -0x10(%rbp),%r14
+        // mov    -0x8(%rbp),%r15
+        // leaveq 
+        // retq
+        //
+        // When we have no idea about return value but we'll
+        // definitely jump and not return.
+
+        if(instr_i == RET && last_checkpoint) {
+            for(i = 1 + last_checkpoint; i <= j; i++) {
+                frame->code[i].will_ret = 1;
+            }
+            last_checkpoint = 0;
+        }
+    }
+
+    do {
+        external_marked = 0;
+        
+        // This is the pass for cases:
+        //
+        //      nopw   0x0(%rax,%rax,1)
+        //      mov    -0xe8(%rbp),%rdi
+        //      callq  0xffffffff81097740 <up_read>
+        //      jmp    0xffffffff81044554 <__do_page_fault+452>
+        //
+        // where the last jump address is the address marked
+        // on the previous pass.
+        //
+        // OR
+        //
+        //      callq  0xffffffff81043f40 <bad_area_nosemaphore>
+        //      jmpq   0xffffffff81044554 <__do_page_fault+452>
+        // 
+        // Here we'll mark only the JMP line, because the first one
+        // is the call of subsequent function.
+        //
+        // OR
+        //
+        //      leaveq              <--------------------------------|
+        //      retq                                                 |
+        //      mov    -0xe8(%rbp),%rdi                              |
+        //      callq  0xffffffff81097740 <up_read>                  |
+        //      jmp    0xffffffff81044554 <__do_page_fault+452> -----|
+        // 
+        // In this case we'll mask only `mov`, `call` and `jmp`
+        do {
+            internal_marked = 0;
+            last_checkpoint = 0;
+            for(j = 0; j < frame->len; j++) {
+                if(0 == *frame->code[j].cmd || frame->code[j].will_ret)
+                    continue;
+                instr_i = find_instr(frame->code[j].cmd, NULL);
+                if(
+                        (JNE <= instr_i && instr_i <= JZ && instr_i != JMP) ||
+                        (CALL == instr_i && (j + 1) < frame->len && frame->code[j + 1].rip == frame->rip) ||
+                        (RET == instr_i)
+                  ) {
+                    last_checkpoint = j;
+                } else if(instr_i == JMP && last_checkpoint) {
+                    jump_to = str2dec(frame->code[j].first, NULL);
+                    for (i = 0; i < frame->len; i++) {
+                        if(jump_to != frame->code[i].rip)
+                            continue;
+                        else
+                            break;
+                    }
+                    if(jump_to == frame->code[i].rip && frame->code[i].will_ret) {
+                        for(k = last_checkpoint + 1; k <= j; k++) {
+                            if(frame->code[k].will_ret == 0) {
+                                frame->code[k].will_ret = 1;
+                                internal_marked = 1;
+                            }
+                        }
+                    }
+                    last_checkpoint = j;
+                }
+            }
+        } while(internal_marked);
+
+        // This is the pass for case:
+        //      mov    0x28(%rbx),%rax
+        //      or     $0x84,%dh
+        //      mov    %edx,0x50(%rbx)
+        //      mov    0x38(%rax),%rdx
+        //      test   %rdx,%rdx
+        //      je     0xffffffff810de31d <handle_edge_irq+349>
+        //
+        //  when the next line after JE instruction already marked
+        //  (will_ret = 1) and the instruction at <handle_edge_irq+349> 
+        //  is also marked (will_ret = 1), that means we can't get into
+        //  current block.
+    
+        do {
+            internal_marked = 0;
+            last_checkpoint = 0;
+            for(j = 0; j < frame->len; j++) {
+                if(0 == *frame->code[j].cmd)
+                    continue;
+                instr_i = find_instr(frame->code[j].cmd, NULL);
+                if(is_jump_instruction(instr_i) && instr_i != JMP && last_checkpoint && ((j + 1) < frame->len && frame->code[j + 1].will_ret == 1)) {
+                    jump_to = str2dec(frame->code[j].first, NULL);
+                    for (i = 0; i < frame->len; i++) {
+                        if(jump_to != frame->code[i].rip)
+                            continue;
+                        else
+                            break;
+                    }
+                    if(jump_to == frame->code[i].rip && frame->code[i].will_ret) {
+                        for(k = last_checkpoint + 1; k <= j; k++) {
+                            if(frame->code[k].will_ret == 0) {
+                                frame->code[k].will_ret = 1;
+                                internal_marked = 1;
+                                external_marked = 1;
+                            }
+                        }
+                    }
+                    last_checkpoint = 0;
+                } else if(
+                        (JNE <= instr_i && instr_i <= JZ) ||
+                        (CALL == instr_i && (j + 1) < frame->len && frame->code[j + 1].rip == frame->rip)
+                ) {
+                    last_checkpoint = j;
+                }
+
+            }
+            
+        } while(internal_marked);
+    } while(external_marked);
+
+    close_tmpfile();
+}
+
+void update_flags(
+        uint64_t s, enum e_registers sreg_i,
+        uint64_t d, enum e_registers dreg_i,
+        uint64_t r, unsigned char cf,
+        struct parameter_registers *regs
+) {
+    regs->cf = cf;
+    if(r)
+        regs->zf = 0;
+    else
+        regs->zf = 1;
+
+    if(r & registers_msb[dreg_i % 5])
+        regs->sf = 1;
+    else
+        regs->sf = 0;
+
+    // Sign-extension of source & destination
+    if(s & registers_msb[sreg_i % 5])
+        s |= !(registers_mask[dreg_i % 5]);
+    if(d & registers_msb[sreg_i % 5])
+        d |= !(registers_mask[dreg_i % 5]);
+
+    if(((int64_t)d > (int64_t)s))
+        regs->of = regs->sf;
+    else if(((int64_t)d < (int64_t)s))
+        regs->of = regs->sf ? 0 : 1;
+    else
+        regs->of = 0;
+}
+
+uint8_t parse_argument(struct stack_parser_context *ctx, struct parameter_registers *r, char *s_arg, enum e_registers *reg_i, uint64_t *arg, uint8_t *reliable) {
+    char *p;
+    uint64_t displ;
+
+    if(reliable)
+        *reliable = 1;
+    *reg_i = find_register(s_arg);
+    if(INVALID != *reg_i)
+        *arg = get_reg(r, *reg_i);
+    else if(strstr(s_arg, "(")) {
+        if(0 == get_memory_operand(s_arg, r, arg) && reliable)
+            *reliable = 0;
+        return 1;
+    } else if(NULL != (p = strstr(s_arg, "%gs:"))) {
+        displ = str2dec(p + 4, NULL);
+        *arg = displ + kt->__per_cpu_offset[ctx->tc->processor];
+        *reg_i = GS_REG;
+    } else
+        *arg = str2dec(s_arg, NULL);
+
+    return 0;
+}
+
+uint8_t parse_frame(
+        struct stack_parser_context *ctx,
+        uint8_t may_call,
+        uint8_t update_sp,
+        uint8_t (*callback)(enum e_instructions, char*, char*)
+) {
+        enum e_registers reg_i[3]; /* indices for operands */
+        enum e_instructions instr_i;
+        int width;
+        char *e;
+        int line_i, old_line_i;
+        uint64_t arg, arg2, res;
+        uint8_t cf;
+        uint8_t is_s_memory_operand, is_d_memory_operand;
+        char *calling_symbol;
+        uint64_t jump_to = 0;
+        int8_t except_no;
+        struct stack_frame_t *frame = ctx->frames + ctx->to_be_processed;
+        struct parameter_registers *regs = &frame->regs;
+        struct parameter_registers *prev_regs = NULL;
+        if(ctx->to_be_processed < ctx->frames_count - 1)
+            prev_regs = &((frame + 1)->regs);
+
+
+        if(!frame->rip && !frame->symbol[0]) {
+            _VERBOSE(fp, ">>> Calling a NULL-pointer\n");
+            return (uint8_t)-1;     // In fact, abnormal return
+        }
+
+        _VERBOSE(fp, "\nSymbol: %s; RIP: 0x%lx; RSP: tracked: 0x%lx, calculated: 0x%lx\n", 
+                frame->symbol, frame->rip, get_reg(regs, RSP) /* *((uint64_t *)p_regs(RSP)) */, frame->rsp
+        );
+
+        except_no = get_exception_no(frame->symbol);
+
+        if(frame->rsp) {
+            set_reg(regs, RSP, frame->rsp);
+            set_reliable(regs, RSP);
+            _VERBOSE(fp, "\t\tValue of %s is 0x%lx now\n", s_registers[RSP], get_reg(regs, RSP) /* *((uint64_t *)p_regs(dreg_i))*/);
+        } else {
+            add_reg(regs, RSP, -0x8);
+            set_reliable(regs, RSP);
+            _VERBOSE(fp, "\t\tValue of %s is 0x%lx now\n", s_registers[RSP], get_reg(regs, RSP) /* *((uint64_t *)p_regs(dreg_i))*/);
+        }
+
+        if(
+                -1 != except_no || 
+                0 == strcmp(frame->symbol, "common_interrupt") ||
+                0 == strcmp(frame->symbol, "apic_timer_interrupt")
+        ) {
+            *((uint64_t *)p_regs(RSP)) &= ~((uint64_t )0x8); // Stack in exceptions aligned
+            // Stack in case of exceptions:
+            //
+            // +0x00 - Error code
+            // +0x08 - Return RIP
+            // +0x10 - Returt CS
+            // +0x18 - Returt RFLAGS
+            // +0x20 - Returt RSP
+            // +0x28 - Returt SS
+            //
+            // But for some exceptions there is no error-code on stack
+            if(0 == strcmp(frame->symbol, "common_interrupt"))
+                add_reg(regs, RSP, 0 - 0x28 - 0x8); /* 0x8 - is for earlier pushed IRQ number (ENTRY irq_entries_start) */
+            else if(0 == strcmp(frame->symbol, "apic_timer_interrupt"))
+                add_reg(regs, RSP, 0 - 0x28);
+            else
+                add_reg(regs, RSP, 0 - get_exception_displacement(except_no));
+            set_reliable(regs, RSP);
+            _VERBOSE(fp, "Exception: %s\t\tValue of %s is 0x%lx now\n", frame->symbol, s_registers[RSP], get_reg(regs, RSP) /* *((uint64_t *)p_regs(dreg_i))*/);
+        }
+
+        for(line_i = 0; line_i < frame->len; ) {
+            _VERBOSE(fp, "\n");
+
+// shortcuts
+#define sreg_i (reg_i[0])
+#define dreg_i (reg_i[1])
+#define command (frame->code[line_i].cmd)
+#define first   (frame->code[line_i].first)
+#define second  (frame->code[line_i].second)
+#define third   (frame->code[line_i].third)
+            uint64_t addr   = frame->code[line_i].rip;
+            uint8_t reliable_memory_operand;
+            int unreliable_flags = 0;
+
+            regs->rip = frame->code[line_i + 1].rip;
+            set_reliable(regs, RIP);
+
+            frame->code[line_i].hit++;
+            if(2 < frame->code[line_i].hit) {
+                // If we got stuck, then clean all registers
+                // and flags and start parsing with the
+                // nearest to `call` address
+                while(frame->code[line_i].rip != frame->nearest) {
+                    if(frame->code[line_i].rip < frame->nearest)
+                        line_i++;
+                    else if(frame->code[line_i].rip > frame->nearest)
+                        line_i--;
+                    if(line_i < 0 || line_i > frame->len)
+                        return (uint8_t)-1;
+                }
+                regs->reliable    = 0ULL;
+                regs->params_mask = 0ULL;
+                regs->was_touched = (unsigned long long) -1LL;
+                memset(regs->params_regs, 0xff, RCOUNT);
+                
+                set_reliable(regs, RBP);
+                set_reliable(regs, RSP);
+                
+                regs->zf = -1;
+                regs->cf = -1;
+                regs->sf = -1;
+                continue;
+            }
+
+            instr_i = find_instr(command, &width);
+            if((0 == frame->rip && instr_i == RET) || (frame->rip && addr == frame->rip))
+                break;
+            
+            _VERBOSE(fp, "++++ <%s at 0x%lx> %s %s", frame->symbol, addr, command, first);
+            if(second && *second)
+                _VERBOSE(fp, ", %s", second);
+            if(third && *third)
+                _VERBOSE(fp, ", %s", third);
+
+            // op   src,dst
+            // arg  - source
+            // arg2 - destination
+            is_s_memory_operand = parse_argument(ctx, regs, first, reg_i + 0, &arg, &reliable_memory_operand);
+            if(0 == reliable_memory_operand) {
+                if(INVALID != (dreg_i = find_register(second)))
+                    regs->was_touched |= (1 << (dreg_i / 5));
+                line_i++;
+                continue;
+            }
+
+            is_d_memory_operand = parse_argument(ctx, regs, second, reg_i + 1, &arg2, &reliable_memory_operand);
+            if(0 == reliable_memory_operand) {
+                line_i++;
+                continue;
+            }
+
+            switch(instr_i) {
+                case NOP:
+                    break;
+                case DEC:
+                case INC:
+                    if(INVALID != sreg_i) {
+                        if(sreg_i == GS_REG && arg == ctx->irq_count_offset) {
+                            ctx->irq_count += (instr_i == INC ? 1 : -1);
+                            arg = ctx->irq_count;
+                            _VERBOSE(fp, "\t\tPERCPU IRQ: %lu\t", arg);
+                        } else {
+                            add_reg(regs, sreg_i, (instr_i == INC ? 1 : -1));
+                        }
+                        if(0 == arg)
+                            regs->zf = 1;
+                        else
+                            regs->zf = 0;
+                    }
+                    break;
+                case LEA:
+                case MOV:
+                case MOVABS:
+                case MOVSBL:
+                case MOVSLQ:
+                case MOVZBL:
+                case MOVZWL:
+                case CMOVE:
+                case CMOVNE:
+                    // Look at the end of `case MOV`.
+                    // If dest register is callee-save,
+                    // then we'll clean 
+                    // created 'callee-save => parameter' mapping
+                    clean_mapping(regs, dreg_i);
+                    if(0 == ctx->should_get_stack_value)
+                        break;
+
+                    if(instr_i == CMOVE && 0 == regs->zf)
+                        break;
+                    if(instr_i == CMOVNE && 1 == regs->zf)
+                        break;
+
+                    if(sreg_i == GS_REG) {
+                        if(INVALID != dreg_i && (update_sp || !is_stack_register(dreg_i) ))
+                            set_reg(regs, dreg_i, get_stack_value(ctx, /*disp + kt->__per_cpu_offset[ctx->tc->processor] */ arg, width));
+                        _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[dreg_i], get_reg(regs, dreg_i));
+                        set_reliable(regs, dreg_i);
+                        break;
+                    }
+
+                    if(dreg_i == GS_REG) {
+                        if(INVALID == sreg_i)
+                            break;
+                        if(INVALID != sreg_i && (update_sp || !is_stack_register(sreg_i)))
+                            set_reg(regs, sreg_i, get_stack_value(ctx, /* disp + kt->__per_cpu_offset[ctx->tc->processor] */ arg2, width));
+                        _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[sreg_i], get_reg(regs, sreg_i));
+                        break;
+                    }
+
+                    // If instruction is like
+                    // 'lea    %rax,(%rdx,%rcx,4)'
+                    // 'mov    %rdi,0x78(%rsp)'
+                    if(is_d_memory_operand) {
+                        if(!arg2)
+                            break;
+                        if(instr_i == MOV)
+                            arg2 = get_stack_value(ctx, arg2, width);
+                        if(sreg_i == INVALID)    // Can't do anything useful here, just skip
+                            break;
+                        set_reg(regs, sreg_i, arg2);
+                        _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[sreg_i], get_reg(regs, sreg_i));
+                        if(instr_i == MOV) {
+                            // Meanwhle let's fill registers from
+                            // previous frame
+                            if(0 == may_call && 0 != ctx->parent) {
+                                set_reg(&(ctx->parent->frames + ctx->parent->to_be_processed)->regs, sreg_i, get_reg(regs, sreg_i));
+                                fill_mapped_register(ctx->parent, sreg_i);
+                            } else
+                                fill_mapped_register(ctx, sreg_i);
+                        }
+
+                        if(error_occured_while_reading)
+                            clean_reliable(regs, dreg_i);
+                        else
+                            set_reliable(regs, sreg_i);
+
+                        break;
+                    }
+
+                    // If instruction is like
+                    // 'mov    0x42(%rdx,%rax,1),%r13d'
+                    if(is_s_memory_operand) {
+                        if(!arg)
+                            break;
+
+                        if(instr_i == MOVZBL || instr_i == MOVSBL)
+                            width = 8;
+                        if(instr_i == MOVZWL)
+                            width = 16;
+                        if(instr_i == MOVSLQ)
+                            width = 32;
+                        if(instr_i != LEA)
+                            arg = get_stack_value(ctx, arg, width);
+                        if(instr_i == MOVSBL && (arg > 0x7f))
+                            arg = 0xffffffffffffff00 | arg;
+                        if(instr_i == MOVSLQ && (arg > 0x7fffffff))
+                            arg = 0xffffffff00000000 | arg;
+
+                        set_reg(regs, dreg_i, arg);
+                        _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[dreg_i], get_reg(regs, dreg_i) /**((uint64_t *)p_regs(dreg_i))*/ );
+
+                        if(error_occured_while_reading)
+                            clean_reliable(regs, dreg_i);
+                        else
+                            set_reliable(regs, dreg_i);
+
+                        break;
+                    }
+
+                    if(INVALID != dreg_i) {
+                        if(INVALID == sreg_i) {
+                            set_reliable(regs, dreg_i);
+                        } else {
+                            if(is_reliable(regs, sreg_i)) {
+                                set_reliable(regs, dreg_i);
+                            } else
+                                clean_reliable(regs, dreg_i);
+                        }
+                        // <`Basic architecture` manual>
+                        // 3.4.1.1 General-Purpose Registers in 64-Bit Mode
+                        if(32 == get_register_width(dreg_i) && 32 == get_register_width(sreg_i))
+                            set_reg(regs, REGISTER_64BIT(dreg_i), 0);
+                        // </`Basic architecture` manual>
+
+                        set_reg(regs, dreg_i, arg);
+                        _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[dreg_i], get_reg(regs, dreg_i));
+                    }
+
+
+                    // Let's follow registers passed as parameters
+                    // for next function, that is
+                    //      mov    %r13,%rcx
+                    //      mov    %rax,%rdx
+                    //      mov    %r12,%rsi
+                    //      mov    %rbx,%rdi
+                    //      callq  *%r8
+                    // 1. If mapping 'callee-save => parameter' found
+                    // go through array and clean previous (is exists)
+                    // mapping.
+                    // 2. Create new mapping
+                    if(
+                            ((INVALID != dreg_i && is_param_register(dreg_i)) &&
+                             (INVALID != sreg_i && is_callee_save_register(sreg_i))) ||
+                            ((INVALID != sreg_i && is_param_register(sreg_i)) && 
+                             (INVALID != dreg_i && is_callee_save_register(dreg_i))
+                            )
+                      )
+                    {
+                        // If found params register in destination,
+                        // clean possible mapping
+                        clean_mapping(regs, dreg_i);
+
+                        set_mapping(regs, sreg_i, dreg_i);
+
+                        if(is_reliable(regs, sreg_i)) {
+                            set_reliable(regs, dreg_i);
+                        } else  {
+                            clean_reliable(regs, dreg_i);
+                        }
+                    }
+                    break;
+                case PUSHF:
+                    add_reg(regs, RSP, -8);
+                            _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[RSP], get_reg(regs, RSP) /* *((uint64_t *)p_regs(dreg_i))*/);
+                    break;
+                case PUSH:
+                    add_reg(regs, RSP, -8);
+                    _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[RSP], get_reg(regs, RSP) /* *((uint64_t *)p_regs(dreg_i))*/);
+                    if(update_sp) {
+                        if(update_sp && INVALID != sreg_i) {
+                            set_reliable(regs, sreg_i);
+                            arg = get_stack_value(ctx, get_reg(regs, RSP), width);
+                            set_reg(regs, sreg_i, arg);
+                            _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[sreg_i], get_reg(regs, sreg_i) /* *((uint64_t *)p_regs(dreg_i))*/);
+                            fill_mapped_register(ctx, sreg_i);
+                        }
+                    }
+                    break;
+                case POPF:
+                case POP:
+                    *((unsigned long long *)p_regs(RSP)) += sizeof(long long);
+                            _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[RSP], get_reg(regs, RSP) /* *((uint64_t *)p_regs(dreg_i))*/);
+                    break;
+                case NOT:
+                    if(INVALID == sreg_i)
+                        break;
+                    arg = ~arg;
+                    set_reg(regs, sreg_i, arg);
+                    regs->zf = arg ? 0 : 1;
+                    _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[sreg_i], get_reg(regs, sreg_i)/* *((uint64_t *)p_regs(dreg_i))*/);
+                    break;
+                case SUB:
+                case SBB:
+                case ADD:
+                case XADD:
+                case AND:
+                case OR:
+                case XOR:
+                    if(instr_i == SBB && regs->cf == -1) // CF unknown, can't process
+                        break;
+
+                    if(INVALID == dreg_i) // Can't do anything useful here, just skip
+                        break;
+
+                    if(
+                        // Same register as `src` and `dst`
+                        ((dreg_i == sreg_i) && (instr_i == XOR || is_reliable(regs, sreg_i))) ||
+                        // Reliable `dst` and (reliable `src` || not register as `src`)
+                        (instr_i != XADD && (INVALID == sreg_i || is_reliable(regs, sreg_i)) && is_reliable(regs, dreg_i)) ||
+                        (instr_i == XADD && (INVALID == dreg_i || is_reliable(regs, dreg_i)) && is_reliable(regs, sreg_i))
+                    ) {
+                        if(instr_i == SBB)
+                            arg += regs->cf;
+
+                        _VERBOSE(fp, "\t\tOperands: 0x%lx and 0x%lx", arg, arg2);
+
+                        if(ADD == instr_i || XADD == instr_i)
+                            cf = ((arg + arg2) < arg) && ((arg + arg2) < arg2);
+                        else if(instr_i == SUB || instr_i == SBB)
+                            cf = arg > arg2;
+                        else
+                            cf = 0;
+
+                        switch(instr_i) {
+                            case SUB:
+                            case SBB:   res = arg2 - arg; break;
+                            case XADD:
+                            case ADD:   res = arg2 + arg; break;
+                            case AND:   res = arg2 & arg; break;
+                            case OR:    res = arg2 | arg; break;
+                            case XOR:   res = arg2 ^ arg; break;
+                            default: break;
+                        }
+
+                        update_flags(arg, sreg_i, arg2, dreg_i, res, cf, regs);
+
+                        if(instr_i == OR || instr_i == XOR || instr_i == AND)
+                            regs->of = 0;
+
+                        // `Basic architecture` manual
+                        // 3.4.1.1 General-Purpose Registers in 64-Bit Mode
+                        if(32 == get_register_width(dreg_i))
+                            set_reg(regs, REGISTER_64BIT(dreg_i), 0);
+                        if(instr_i == XADD) {
+                            if(INVALID != sreg_i)
+                                set_reg(regs, sreg_i, arg2);
+                            if(INVALID != dreg_i)
+                                set_reg(regs, dreg_i, res);
+                        } else
+                            set_reg(regs, dreg_i, res);
+                        if(sreg_i != INVALID)
+                            clean_mapping(regs, sreg_i);
+                        clean_mapping(regs, dreg_i);
+                        set_reliable(regs, dreg_i);
+                        _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[dreg_i], get_reg(regs, dreg_i));
+                    }
+
+                    break;
+                case CALL:
+                    if(first && *first) {
+                        e = strstr(first, " ");
+                        calling_symbol = closest_symbol(str2dec(first, e));
+                        if(calling_symbol)
+                            _VERBOSE(fp, "\t\tcalling '%s'", calling_symbol);
+                        if(may_call && calling_symbol && 
+                                (
+                                 0 == strcmp(calling_symbol, "error_entry") ||
+                                 0 == strcmp(calling_symbol, "irq_to_desc") ||
+                                 0 == strcmp(calling_symbol, "kexec_should_crash") ||
+                                 0 == strcmp(calling_symbol, "save_args") ||
+                                 0 == strncmp(calling_symbol, "__get_user_", 11)
+                                 )
+                        ) {
+                            _VERBOSE(fp, "\t\tprocessing call");
+                            uint8_t exits_on_callback = 0;
+
+                            // Call recursively
+                            add_reg(regs, RSP, -8);
+                            struct stack_frame_t recursive_frame = {
+                                .rip    = 0,
+                                .rsp    = get_reg(regs, RSP)
+                            };
+                            strncpy(recursive_frame.symbol, calling_symbol, 64);
+                            disassemble_frame(&recursive_frame, 1);
+                            memcpy(&recursive_frame.regs, regs, sizeof(struct parameter_registers));
+                            recursive_frame.regs.was_touched = regs->was_touched;
+
+                            struct stack_parser_context t_ctx = {
+                                .frames = &recursive_frame,
+                                .frames_count = 1,
+                                .to_be_processed = 0,
+                                .should_get_stack_value = 1,
+                                .tc = ctx->tc,
+                                .irq_count_offset = ctx->irq_count_offset,
+                                .irq_count = ctx->irq_count,
+                                .parent = ctx,
+                            };
+                            exits_on_callback = parse_frame(&t_ctx, 0, update_sp, callback);
+
+                            memcpy(regs, &recursive_frame.regs, sizeof(struct parameter_registers));
+
+                            regs->was_touched = recursive_frame.regs.was_touched;
+                            ctx->irq_count = t_ctx.irq_count;
+                            add_reg(regs, RSP, 8);
+                        } else if(function_returns_value(closest_symbol(str2dec(first, e)))) {
+                            set_reg(regs, RAX, 0xdeadbeaf);
+                            clean_reliable(regs, RAX);
+                        }
+                    }
+                    break;
+                case JA:
+                case JB:
+                case JE:
+                case JZ:
+                case JL:
+                case JS:
+                case JAE:
+                case JBE:
+                case JNE:
+                case JNZ:
+                case JNS:
+                case JMP:
+                    _VERBOSE(fp, "\n");
+                    // Just Smile And Wave Boys, Smile And Wave 
+        
+                    // Don't jump, while calculating frame size
+                    if(0 == update_sp)
+                        break;
+
+                    // Find line
+                    jump_to = str2dec(first, NULL);
+                    old_line_i = line_i;
+                    while(frame->code[line_i].rip != jump_to) {
+                        if(frame->code[line_i].rip < jump_to)
+                            line_i++;
+                        else if(frame->code[line_i].rip > jump_to)
+                            line_i--;
+                        if(line_i < 0 || (line_i >= frame->len))
+                            return (uint8_t)-1;
+                    }
+
+                    // If next_line.will_ret != jump_line.will_ret,
+                    // let's jump without checking flags
+                    if((0 == frame->code[line_i].will_ret) && ((old_line_i + 1) < frame->len) && frame->code[old_line_i + 1].will_ret)
+                        // Do jump
+                        continue;
+                    else if(frame->code[line_i].will_ret && ((old_line_i + 1) < frame->len) && (0 == frame->code[old_line_i + 1].will_ret)) {
+                        // Don't jump
+                        line_i = old_line_i + 1;
+                        continue;
+                    }
+
+                    // Check flags
+                    if(
+                            (may_call == 1 && instr_i != JMP && frame->code[line_i].will_ret) ||
+                            ((instr_i == JE || instr_i == JZ) && regs->zf == 1) ||
+                            ((instr_i == JNE || instr_i == JNZ) && regs->zf == 0) ||
+                            (instr_i == JA && regs->cf == 1 && regs->zf == 1) ||
+                            (instr_i == JAE && regs->cf == 1) ||
+                            (instr_i == JNS && regs->sf == 0) ||
+                            ((instr_i == JB || instr_i == JC) && regs->cf == 1) ||
+                            ((instr_i == JL) && regs->of != regs->sf) ||
+                            ((instr_i == JL) && regs->sf == 1) ||
+                            ((instr_i == JBE || instr_i == JNA) && (regs->cf == 1 || regs->zf == 1)) ||
+                            (instr_i == JMP) ||
+                            (((line_i + 1) < frame->len) && frame->code[line_i + 1].will_ret)
+                      )
+                        continue;
+                    else
+                        line_i = old_line_i + 1;
+                    continue;
+                case OTHER_JUMP:
+                    _VERBOSE(fp, "\t\tOTHER_JUMP: %s 0x%lx\n", command, arg);
+                    break;
+                case BT:
+                case BTS:
+                case CMP:
+                case TEST:
+                    unreliable_flags = 1;
+                    if(INVALID != sreg_i && 0 == is_reliable(regs, sreg_i))
+                        break;   // Unreliable;
+                    if(INVALID != dreg_i && 0 == is_reliable(regs, dreg_i))
+                        break;   // Unreliable;
+                    if(is_s_memory_operand)
+                        arg = get_stack_value(ctx, arg, width);
+                    if(is_d_memory_operand)
+                        arg2 = get_stack_value(ctx, arg2, width);
+
+                    _VERBOSE(fp, "\t\t testing 0x%lx <=> 0x%lx", arg, arg2);
+                    if(instr_i == CMP)
+                        update_flags(arg, sreg_i, arg2, dreg_i, arg2 - arg, arg > arg2, regs);
+                    if(instr_i == TEST) {
+                        update_flags(arg, sreg_i, arg2, dreg_i, arg & arg2, 0, regs);
+                        regs->of = 0;
+                    }
+                    if(instr_i == BT || instr_i == BTS || instr_i == BTR) {
+                        regs->cf = (arg2 & (arg % width)) ? 1 : 0;
+                        _VERBOSE(fp, "\t\tCarry set to %d", regs->cf);
+                    }
+                        
+                    unreliable_flags = 0;
+                    break;
+                case SHL:
+                case SHR:
+                case SAR:
+                    // SHL and SHR - Logical shift
+                    // SAR and SAL - Arithmetic shift
+                    if((INVALID != dreg_i && !is_reliable(regs, dreg_i)) || (INVALID != sreg_i && !is_reliable(regs, sreg_i)))
+                        break; // Unreliable
+
+                    if(*second) {
+                        if(INVALID == dreg_i)
+                            break;
+                        arg2 = get_reg(regs, dreg_i);
+                    } else {
+                        arg2 = arg;
+                        dreg_i = sreg_i;
+                        arg = 1;
+                    }
+                    while(arg) {
+                        if(instr_i == SHL) {
+                            regs->cf = !((arg2 << 1) == ((arg2 << 1) & registers_mask[dreg_i % 5]));
+                            arg2 = (arg2 << 1) & registers_mask[dreg_i % 5];
+                        } else {
+                            regs->cf = arg2 & 0x1ULL;
+                            if(instr_i == SAR) {
+                                if(registers_msb[dreg_i % 5] & arg2)
+                                    arg2 = (arg2 >> 1) | registers_msb[dreg_i % 5];
+                                else
+                                    arg2 = (arg2 >> 1);
+                            } else
+                                arg2 = arg2 >> 1;
+                        }
+                        arg--;
+                    }
+                    if(0 == arg2)
+                        regs->zf = 1;
+                    else
+                        regs->zf = 0;
+                    set_reg(regs, dreg_i, arg2);
+                    _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[dreg_i], get_reg(regs, dreg_i));
+                    break;
+                case IMUL:
+                    if(INVALID != sreg_i && 0 == is_reliable(regs, sreg_i))
+                        break;
+                    if(INVALID != dreg_i && 0 == is_reliable(regs, dreg_i))
+                        break;
+
+                    _VERBOSE(fp, "\t\tOperands: 0x%lx and 0x%lx", arg, arg2);
+                    res = (uint64_t)arg * (uint64_t)arg2;
+
+                    // Three-operand form
+                    if(*third) {
+                        reg_i[2] = find_register(third);
+                        set_reg(regs, reg_i[2], res);
+                        _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[reg_i[2]], get_reg(regs, reg_i[2]));
+                        set_reliable(regs, reg_i[2]);
+                    } else if(INVALID != dreg_i) {
+                        set_reg(regs, dreg_i, res);
+                        _VERBOSE(fp, "\t\tValue of %s is 0x%lx now", s_registers[dreg_i], get_reg(regs, dreg_i));
+                    }
+
+                    update_flags(
+                            arg, sreg_i, arg2, dreg_i, res,
+                            ((arg < res) || (arg2 < res)), regs
+                    );
+                    break;
+                case LEAVE:
+                    // Don't leave me now
+                    if(0 == update_sp)
+                        break;
+                    set_reg(regs, RSP, get_reg(regs, RBP));
+                    set_reg(regs, RBP, get_stack_value(ctx, get_reg(regs, RSP), 64));
+                    add_reg(regs, RSP, 0x8);
+                    _VERBOSE(fp, "\t\tValue of RSP is 0x%lx now", get_reg(regs, RSP));
+                    _VERBOSE(fp, "\t\tValue of RBP is 0x%lx now", get_reg(regs, RBP));
+                    break;
+                default:
+                    _VERBOSE(fp, "\t\tUNKN");
+                    unreliable_flags = 1;
+                    break;
+            }
+            if(!is_compare_instruction(instr_i)) {
+                if(*third && INVALID != reg_i[2])
+                    regs->was_touched |= (1 << (reg_i[2] / 5));
+                else if(0 == *third && INVALID != dreg_i)
+                    regs->was_touched |= (1 << (dreg_i / 5));
+            }
+            if(unreliable_flags) {
+                regs->zf = -1;
+                regs->cf = -1;
+                regs->sf = -1;
+                if(dreg_i >= 0)
+                    clean_reliable(regs, dreg_i);
+            }
+            if(NULL != callback)
+                if(1 == callback(instr_i, first, second)) {
+                    _VERBOSE(fp, "\ncallback returns successfully: %s %s, %s\n", command, first, second);
+                    return 1;
+                }
+            line_i++;
+            error_occured_while_reading = 0;
+        }
+#undef sreg_i
+#undef dreg_i
+#undef command
+#undef first
+#undef second
+#undef third
+        return 0;
+}
+
+void parse_stack(struct bt_info *bt) {
+        unsigned char frames = 0;
+        unsigned int i;
+        struct parameter_registers *regs, *prev_regs = NULL;
+
+        struct stack_parser_context ctx;
+        struct stack_frame_t *frame;
+
+        ctx.frames = calloc(64, sizeof(struct stack_frame_t));
+        ctx.tc = task_to_context(bt->task);
+
+
+        ctx.should_get_stack_value = 0;
+        fill_frames(bt, &ctx);
+        ctx.irq_count = -1;
+        ctx.should_get_stack_value = 1;
+        i = frames;
+//        return;
+        for(i = ctx.frames_count - 1; i > 0; i--) {
+                ctx.to_be_processed = i;
+                frame = ctx.frames + i;
+                regs = &frame->regs;
+                if(prev_regs)
+                    memcpy(regs, prev_regs, sizeof(struct parameter_registers));
+                regs->was_touched = 0;
+                parse_frame(&ctx, 1, 1, NULL);
+
+                prev_regs = regs;
+        }
+        _VERBOSE(fp, "\n\nBacktrace:\n");
+        for(i = 0; i < ctx.frames_count - 1; i++)
+            print_proto(ctx.frames + i, i, &(ctx.frames + i + 1)->regs);
+        for(i = 0; i < ctx.frames_count; i++)
+            if((ctx.frames + i)->allocated)
+                free((ctx.frames + i)->code);
+        free(ctx.frames);
+            
+}
+        
+
 #define STACK_TRANSITION_ERRMSG_E_I_P \
 "cannot transition from exception stack to IRQ stack to current process stack:\n    exception stack pointer: %lx\n          IRQ stack pointer: %lx\n      process stack pointer: %lx\n         current stack base: %lx\n" 
 #define STACK_TRANSITION_ERRMSG_E_P \
